#!/usr/bin/env bash
# FinalWall-Guardian.sh
# 终极智能防火墙守护与优化脚本
# 版本: 7.0.0 (工业级稳定版)
# 目标: Debian 12/13, 作为任何部署流程的最后一步，提供极致安全与性能
set -euo pipefail
IFS=$'\n\t'

# ==============================================================================
# --- 用户配置 (几乎无需修改) ---
# ==============================================================================

# --- 1. [可选] 端口转发规则 (Port Forwarding / DNAT) ---
# 用于转发到其他服务器，或处理Docker等容器化应用的端口映射。
declare -a PORT_FORWARD_RULES=()

# --- 2. [固定] 必须放行的入站端口 ---
declare -a MANDATORY_INBOUND_TCP=(
  22      # 您的SSH端口号
)
declare -a MANDATORY_INBOUND_UDP=()


# ==============================================================================
# --- 脚本主体 (通常无需修改) ---
# ==============================================================================
VERSION="7.0.0-2025-10-18"
APPLY=0
LOG_FILE="/var/log/FinalWall-Guardian.log"
declare -A SYS

### ========== 日志与命令执行助手 ==========
_log_to_file(){ echo "[$(date +'%F %T')] $*" >> "$LOG_FILE"; }
_log(){ printf "\033[36m[%s]\033[0m %s\n" "$(date +%T)" "$*"; _log_to_file "INFO: $*"; }
_ok(){ printf "\033[32m[✓]\033[0m %s\n" "$*"; _log_to_file "SUCCESS: $*"; }
_warn(){ printf "\033[33m[!]\033[0m %s\n" "$*" >&2; _log_to_file "WARNING: $*"; }
_err(){ printf "\033[31m[✗]\033[0m %s\n" "$*" >&2; _log_to_file "ERROR: $*"; exit 1; }

### ========== 参数解析 ==========
usage(){ cat <<EOF
Usage: sudo $0 [--apply]
  默认: Dry-run模式，扫描端口并显示将要生成的配置，不应用。
  --apply: 备份现有规则，应用新配置，并启动SSH防锁死保护。
EOF
exit 0; }

while [ $# -gt 0 ]; do
  case "$1" in
    --apply) APPLY=1; shift;;
    -h|--help) usage;;
    *) _err "未知参数: $1";;
  esac
done

### ========== 系统自检与依赖安装 ==========
pre_flight_checks() {
  touch "$LOG_FILE" || _err "无法写入日志文件: $LOG_FILE"
  _log "脚本启动 (Version: $VERSION)"
  [ "$(id -u)" -ne 0 ] && _err "请以 root 权限运行此脚本"
  
  local pkgs_to_install=""
  command -v nft >/dev/null 2>&1 || pkgs_to_install+=" nftables"
  command -v ss >/dev/null 2>&1 || pkgs_to_install+=" iproute2"
  
  if [ -n "$pkgs_to_install" ]; then
    _log "检测到依赖缺失，正在尝试自动安装:${pkgs_to_install}..."
    if [ "$APPLY" -eq 1 ]; then
      apt-get update -y >/dev/null && apt-get install -y $pkgs_to_install >/dev/null || _err "依赖自动安装失败，请手动安装后重试。"
      _ok "依赖安装成功。"
    else
      _warn "Dry-run模式：跳过依赖安装。请注意，后续步骤可能失败。"
    fi
  fi
  
  SYS[iface]=$(ip -o route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}' | head -1 || true)
  [ -z "${SYS[iface]}" ] && _err "无法检测到主网络接口"
}

### ========== 智能端口扫描 (增强版) ==========
scan_listening_ports() {
  _log "正在智能扫描本机所有公网监听端口 (带进程信息)..."
  
  echo "--- [TCP Listeners on 0.0.0.0 or ::] ---"
  ss -tlpn 2>/dev/null | grep 'LISTEN' | grep -E '0\.0\.0\.0:|\[::\]:' | cat
  echo "--- [UDP Listeners on 0.0.0.0 or ::] ---"
  ss -ulpn 2>/dev/null | grep -E '0\.0\.0\.0:|\[::\]:' | cat
  echo "-------------------------------------------"
  _warn "注意: 仅扫描监听在 '0.0.0.0' 或 '[::]' 上的服务。Docker容器或绑定特定IP的服务需手动配置 PORT_FORWARD_RULES。"

  local tcp_ports udp_ports
  tcp_ports=$(ss -tlpn 2>/dev/null | grep 'LISTEN' | awk '{print $4}' | grep -E '0\.0\.0\.0:|\[::\]:' | sed 's/.*://' | sort -un)
  udp_ports=$(ss -ulpn 2>/dev/null | awk '{print $5}' | grep -E '0\.0\.0\.0:|\[::\]:' | sed 's/.*://' | sort -un)

  local all_tcp all_udp
  all_tcp=$( (printf '%s\n' "${MANDATORY_INBOUND_TCP[@]}" ; echo "$tcp_ports") | sort -un | tr '\n' ',' | sed 's/,$//' )
  all_udp=$( (printf '%s\n' "${MANDATORY_INBOUND_UDP[@]}" ; echo "$udp_ports") | sort -un | tr '\n' ',' | sed 's/,$//' )

  SYS[allowed_tcp]=$all_tcp
  SYS[allowed_udp]=$all_udp

  _ok "扫描完成。将放行TCP端口: ${all_tcp:-无}"
  _ok "扫描完成。将放行UDP端口: ${all_udp:-无}"
}

### ========== 终极配置生成 (工业级稳定版) ==========
generate_ultimate_config() {
  _log "正在生成终极 nftables 与 sysctl 配置文件..."
  local nft_config=""
  local sysctl_config=""

  # --- Part 1: Nftables Rules (终极兼容语法) ---
  nft_config+="#!/usr/sbin/nft -f\n\n"
  nft_config+="# Generated by FinalWall-Guardian.sh v${VERSION}\n"
  nft_config+="flush ruleset\n\n"
  
  nft_config+="table inet filter {\n"
  nft_config+="    chain input { type filter hook input priority filter; policy drop;\n"
  nft_config+="        iifname lo accept\n        ct state established,related accept\n        ct state invalid drop\n"
  nft_config+="        ip protocol icmp accept\n        ip6 nexthdr icmpv6 accept\n"
  # 最通用的SYN Flood防护
  nft_config+="        tcp flags syn limit rate 50/second burst 100 packets accept\n"
  [ -n "${SYS[allowed_tcp]}" ] && nft_config+="        tcp dport { ${SYS[allowed_tcp]} } accept\n"
  [ -n "${SYS[allowed_udp]}" ] && nft_config+="        udp dport { ${SYS[allowed_udp]} } accept\n    }\n"
  nft_config+="    chain forward { type filter hook forward priority filter; policy accept;\n"
  nft_config+="        ct state established,related accept\n        ct state invalid drop\n    }\n"
  nft_config+="    chain output { type filter hook output priority filter; policy accept;\n    }\n}\n\n"
  
  if [ ${#PORT_FORWARD_RULES[@]} -gt 0 ]; then
    nft_config+="table inet nat {\n"
    local unique_ips=$(for rule in "${PORT_FORWARD_RULES[@]}"; do echo "$rule" | cut -d':' -f3; done | sort -u)
    nft_config+="    set forward_dests { type ipv4_addr; flags interval; elements = { $(echo "$unique_ips" | tr '\n' ',' | sed 's/,$//') } }\n"
    nft_config+="    chain prerouting { type nat hook prerouting priority dstnat; policy accept;\n"
    for rule in "${PORT_FORWARD_RULES[@]}"; do IFS=':' read -r proto lport dip dport opt <<< "$rule"; local dnat_rule="iifname \"${SYS[iface]}\" ${proto} dport ${lport}"; if [[ "$opt" == "zone="* ]]; then dnat_rule+=" ct zone set ${opt#*=}"; fi; dnat_rule+=" dnat to ${dip}:${dport}"; nft_config+="        ${dnat_rule}\n"; done
    nft_config+="    }\n"
    nft_config+="    chain postrouting { type nat hook postrouting priority srcnat; policy accept;\n"
    nft_config+="        oifname \"${SYS[iface]}\" ip daddr @forward_dests masquerade\n    }\n}\n"
  fi

  # --- Part 2: Sysctl Optimizations (保守且安全) ---
  sysctl_config+="# Generated by FinalWall-Guardian.sh v${VERSION}\n"
  local default_route_count=$(ip route show default | wc -l)
  local rp_filter_value=1
  if [ "$default_route_count" -gt 1 ]; then
    _warn "检测到多条默认路由，将 rp_filter 设置为 2 (loose) 模式以增强兼容性。"
    rp_filter_value=2
  fi
  sysctl_config+="net.ipv4.conf.all.rp_filter = ${rp_filter_value}\n"
  sysctl_config+="net.ipv4.conf.default.rp_filter = ${rp_filter_value}\n"
  
  local mem_mb=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)
  local conntrack_max=$(( mem_mb * 64 )) # 每GB内存分配64k条目
  [ "$conntrack_max" -lt 65536 ] && conntrack_max=65536
  [ "$conntrack_max" -gt 524288 ] && conntrack_max=524288
  sysctl_config+="net.netfilter.nf_conntrack_max = ${conntrack_max}\n"
  
  sysctl_config+="net.ipv4.tcp_ecn = 0\n"
  sysctl_config+="net.ipv4.tcp_mtu_probing = 1\n" # 替代MSS Clamping
  sysctl_config+="net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30\n"

  SYS[nft_conf]=$nft_config
  SYS[sysctl_conf]=$sysctl_config
}

### ========== 应用配置 (带安全回滚) ==========
apply_config() {
  local nft_conf="${SYS[nft_conf]}"
  local sysctl_conf="${SYS[sysctl_conf]}"
  local nft_file="/etc/nftables.conf"
  local sysctl_file="/etc/sysctl.d/98-finalwall-guardian.conf"
  local tmp_nft_file="/tmp/nft.conf.$$"
  
  echo -e "$nft_conf" > "$tmp_nft_file"
  trap 'rm -f "$tmp_nft_file"' EXIT

  _log "正在严格检查生成的 nftables 配置文件语法..."
  if ! nft -c -f "$tmp_nft_file"; then
    _err "生成的 nftables 配置文件存在语法错误。操作已中止。"
  fi
  _ok "语法检查通过，配置有效。"

  if [ "$APPLY" -eq 1 ]; then
    local backup_dir="/root/FinalWall_Guardian_backups/$(date +%F_%T)"
    mkdir -p "$backup_dir"
    _log "配置备份将保存在: $backup_dir"

    for fw in ufw firewalld netfilter-persistent; do
      if systemctl is-active --quiet "$fw"; then
        _warn "检测到 $fw 服务，正在备份并禁用它..."
        if [ "$fw" = "ufw" ]; then ufw status numbered > "$backup_dir/ufw_status.txt" 2>/dev/null || true; fi
        if [ "$fw" = "firewalld" ]; then cp -r /etc/firewalld "$backup_dir/" 2>/dev/null || true; fi
        systemctl stop "$fw"; systemctl disable "$fw"; systemctl mask "$fw"
        _ok "$fw 已备份并禁用。"
      fi
    done
    
    nft list ruleset > "$backup_dir/nftables_ruleset_before.txt"
    [ -f "$nft_file" ] && cp "$nft_file" "$backup_dir/nftables.conf.bak"

    _log "正在应用 sysctl 网络优化..."
    echo -e "$sysctl_conf" > "$sysctl_file"
    sysctl -p "$sysctl_file" >/dev/null 2>&1 || true
    sysctl --system >/dev/null 2>&1 || true
    
    _log "正在应用 nftables 安全规则..."
    cp "$tmp_nft_file" "$nft_file"
    systemctl restart nftables && systemctl enable nftables

    local ssh_port_to_check=$(printf '%s\n' "${MANDATORY_INBOUND_TCP[@]}" | head -1)
    _ok "规则已应用。启动60秒SSH连接保护，请在1分钟内尝试重连SSH..."
    (
      sleep 60
      if ! ss -tlpn 2>/dev/null | grep -q ":${ssh_port_to_check}\b"; then
        _warn "!!! SSH连接丢失风险警告 !!! 未检测到SSH端口在监听。"
        _warn "!!! 正在自动回滚到之前的防火墙规则... !!!"
        if [ -f "$backup_dir/nftables.conf.bak" ]; then
          cp "$backup_dir/nftables.conf.bak" "$nft_file"
          if nft -c -f "$nft_file"; then
            systemctl restart nftables
            _ok "已成功回滚到备份的 nftables.conf。"
            wall <<< "FinalWall-Guardian: SSH connection lost. Rules have been rolled back to previous state."
          else
            _err "回滚失败：备份文件语法错误。"
            wall <<< "FinalWall-Guardian: SSH connection lost. Rollback FAILED due to invalid backup file."
          fi
        else
          echo "flush ruleset" > "$nft_file"
          systemctl restart nftables
          _warn "无备份文件可回滚，已清空所有规则。"
          wall <<< "FinalWall-Guardian: SSH connection lost. No backup found. All firewall rules have been flushed."
        fi
      else
        _ok "SSH连接验证成功，新规则已安全启用。"
      fi
    ) &
  fi
}

### ========== 主函数 ==========
main() {
  pre_flight_checks
  scan_listening_ports
  generate_ultimate_config

  echo -e "\n\033[1;33m==================== 生成的 sysctl 配置 (预览) ====================\033[0m"
  echo -e "${SYS[sysctl_conf]}"
  echo -e "\033[1;33m==================== 生成的 nftables 配置 (预览) ====================\033[0m"
  echo -e "${SYS[nft_conf]}"
  echo -e "\033[1;33m====================================================================\033[0m"
  
  if [ "$APPLY" -eq 1 ]; then
    apply_config
  else
    _warn "Dry-run 完成。使用 --apply 来写入并启用规则。"
  fi
}

main "$@"
