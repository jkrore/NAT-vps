youxuan.cf.090227.xyz
cf.tencentapp.cn
cf.cloudflare.182682.xyz

mfa.gov.ua
www.shopify.com
store.ubi.com
staticdelivery.nexusmods.com
cf.877774.xyz
saas.sin.fan












# 🌐 域名/IP 列表（不带引号，每行一个）
$domainInput = @'
youxuan.cf.090227.xyz
cf.tencentapp.cn
cf.cloudflare.182682.xyz
mfa.gov.ua
www.shopify.com
store.ubi.com
staticdelivery.nexusmods.com
cf.877774.xyz
saas.sin.fan
'@

# ---> 关键点 1: 自动清理输入列表 <---
# 对列表进行处理：1. 去除注释 (#) 2. 去除首尾空格 3. 筛选非空行 4. 去除重复项
$rawList = $domainInput -split "`r?`n" | ForEach-Object { ($_.Split('#')[0]).Trim() } | Where-Object { $_ } | Sort-Object -Unique

# ⏱️ 为每次 ping 请求设置一个精准的超时时间（毫秒）
$timeoutMilliseconds = 1500 # 1.5 秒

# 📦 使用线程安全的集合来存储结果
$results = [System.Collections.Concurrent.ConcurrentBag[object]]::new()

# 🛠️ 定义将在每个线程中运行的脚本块 (使用 .NET 类以获得最高性能)
$scriptBlock = {
    param($target, $timeout)
    $pingSender = [System.Net.NetworkInformation.Ping]::new()
    try {
        $reply = $pingSender.SendPingAsync($target, $timeout).GetAwaiter().GetResult()
        if ($reply.Status -eq 'Success') {
            [PSCustomObject]@{ Target = $target; AvgLatency = $reply.RoundtripTime; Status = "✅ 正常" }
        } else {
            [PSCustomObject]@{ Target = $target; AvgLatency = $null; Status = "❌ 失败 ($($reply.Status))" }
        }
    } catch {
        [PSCustomObject]@{ Target = $target; AvgLatency = $null; Status = "❌ 超时/解析失败" }
    } finally {
        if ($pingSender) {
            $pingSender.Dispose()
        }
    }
}

# 🚀 配置和创建 Runspace 池
$maxThreads = [Math]::Min(16, ([System.Environment]::ProcessorCount * 2))
$runspacePool = [runspacefactory]::CreateRunspacePool(1, $maxThreads)
$runspacePool.Open()

$jobs = @()

# 🚀 将所有 Ping 任务异步分配到 Runspace 池中
foreach ($target in $rawList) {
    $ps = [powershell]::Create()
    $ps.RunspacePool = $runspacePool
    $null = $ps.AddScript($scriptBlock).AddArgument($target).AddArgument($timeoutMilliseconds)
    $jobs += [PSCustomObject]@{
        Instance = $ps
        Handle   = $ps.BeginInvoke()
    }
}

Write-Host "🚀 已清理并提交 $($jobs.Count) 个唯一 Ping 任务，正在并行处理..."

# ⏳ 等待所有任务完成并收集结果
foreach ($job in $jobs) {
    try {
        $output = $job.Instance.EndInvoke($job.Handle)
        if ($null -ne $output) {
            $results.Add($output)
        }
    } catch {
        # 脚本块内部已处理了大部分失败情况
    } finally {
        $job.Instance.Dispose()
    }
}

# 🧹 关闭并释放 Runspace 池资源
$runspacePool.Close()
$runspacePool.Dispose()

# 📊 排序和筛选最终输出
$finalResults = $results.ToArray()

# ---> 关键点 2: 对成功的连接按延迟 (AvgLatency) 从小到大排序 <---
$success = $finalResults | Where-Object { $_.AvgLatency -ne $null -and $_.AvgLatency -le 50 } | Sort-Object AvgLatency
$failed  = $finalResults | Where-Object { $_.AvgLatency -eq $null }

# 清晰地输出标题，指明筛选条件
Write-Host "`n🏆 Ping 延迟排行榜（延迟 <= 50ms）" -ForegroundColor Cyan
$success | ForEach-Object {
    Write-Host ("{0,-70} : {1,6} ms {2}" -f $_.Target, $_.AvgLatency, $_.Status) -ForegroundColor Green
}

if ($failed.Count -gt 0) {
    Write-Host "`n❌ 无法 Ping 的目标：" -ForegroundColor Red
    $failed | ForEach-Object {
        Write-Host ("{0,-70} : {1}" -f $_.Target, $_.Status) -ForegroundColor DarkRed
    }
}



