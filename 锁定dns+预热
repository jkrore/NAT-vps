#dns查看
cat /etc/resolv.conf


bash <(cat <<EOF
#!/bin/bash
# ====================================================
#   TikTok 运营专用：DNS 极致净化与锁定工具 (Pro版)
# ====================================================

# 1. 定义配色和格式
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "\n\${BLUE}>>> 正在初始化环境检测工具...\${NC}"

# 2. 静默安装依赖
apt update -y >/dev/null 2>&1
apt install dnsutils e2fsprogs curl -y >/dev/null 2>&1

# 3. 执行锁定流程 (解锁 -> 写入 -> 焊死)
chattr -i /etc/resolv.conf 2>/dev/null
echo "nameserver 1.1.1.1" > /etc/resolv.conf
echo "nameserver 8.8.8.8" >> /etc/resolv.conf
chattr +i /etc/resolv.conf

# 4. 获取数据 (核心智能部分)
# 获取本机公网 IP
MY_IP=\$(curl -s https://api.ip.sb/ip -4)
# 获取 DNS 解析 IP (处理 messy output)
# 使用 grep 和 awk 提取纯净 IP，去掉 ecs/ns 等杂讯
DNS_RAW=\$(dig +short TXT whoami.ds.akahelp.net)
DNS_EXIT_IP=\$(echo "\$DNS_RAW" | grep "ip" |  sed 's/.*ip //' | sed 's/"//g' | head -n 1)
# 获取当前 DNS 配置文件内容
CURRENT_CONF=\$(cat /etc/resolv.conf | tr '\n' ' ')
# 获取文件属性
ATTR=\$(lsattr /etc/resolv.conf)

# 5. 输出专业报告
clear
echo -e "\${CYAN}=========================================================\${NC}"
echo -e "           \${YELLOW}🔍 DNS 环境深度体检报告 (TikTok专用)\${NC}"
echo -e "\${CYAN}=========================================================\${NC}"

# --- 检测项 1: 锁定状态 ---
printf "%-30s" "1. 防篡改锁定 (Immutable):"
if [[ "\$ATTR" == *"i"* ]]; then
    echo -e "\${GREEN}[ 已锁死 ✅ ]\${NC}"
else
    echo -e "\${RED}[ 未锁定 ❌ ]\${NC}"
fi

# --- 检测项 2: 配置内容 ---
printf "%-30s" "2. DNS 服务器配置:"
if [[ "\$CURRENT_CONF" == *"1.1.1.1"* ]]; then
    echo -e "\${GREEN}[ 国际标准 ✅ ]\${NC}"
    echo -e "   \${BLUE}↳ 当前值: 1.1.1.1 / 8.8.8.8\${NC}"
else
    echo -e "\${RED}[ 异常/被篡改 ❌ ]\${NC}"
    echo -e "   \${RED}↳ 当前值: \$CURRENT_CONF\${NC}"
fi

# --- 检测项 3: 解析连通性 ---
printf "%-30s" "3. 谷歌解析测试:"
PING_TEST=\$(dig google.com +short | head -n 1)
if [[ -n "\$PING_TEST" ]]; then
    echo -e "\${GREEN}[ 通畅 ✅ ]\${NC}"
else
    echo -e "\${RED}[ 失败/超时 ❌ ]\${NC}"
fi

echo -e "\${CYAN}---------------------------------------------------------\${NC}"

# --- 检测项 4: 泄露智能分析 ---
echo -e "\${YELLOW}4. 泄露风险智能分析:\${NC}"

echo -e "   VPS 本机 IP :  \${CYAN}\$MY_IP\${NC}"
if [[ -z "\$DNS_EXIT_IP" ]]; then
    echo -e "   DNS 出口 IP :  \${RED}检测失败 (Dig命令无返回)\${NC}"
else
    echo -e "   DNS 出口 IP :  \${CYAN}\$DNS_EXIT_IP\${NC}"
fi

# --- 最终结论 ---
echo ""
printf "%-30s" "   🛡️  最终判定:"

# 简单的判断逻辑：如果 DNS 出口 IP 也是本机 IP 段，或者非空，通常代表走了正确的出口
if [[ -n "\$DNS_EXIT_IP" ]]; then
    # 检查是否是中国 IP (简单判断)
    IS_CN=\$(curl -s "http://ip-api.com/json/\$DNS_EXIT_IP" | grep "China")
    if [[ -n "\$IS_CN" ]]; then
         echo -e "\${RED}[ 严重警告：DNS 在中国境内解析 (泄露) ❌ ]\${NC}"
    else
         echo -e "\${GREEN}[ 安全 (纯净国际出口) ✅ ]\${NC}"
    fi
else
    echo -e "\${YELLOW}[ 需要人工复核 ]\${NC}"
fi

echo -e "\${CYAN}=========================================================\${NC}"
EOF
)



















bash <(cat <<EOF
#!/bin/bash
# ==============================================================
#   🚀 TikTok/Google 极速链路预热系统 (Ultimate Edition)
#   功能：DNS缓存刷新 + 路由激活 + HTTP握手预热 + 日志管理
# ==============================================================

# 1. 安装必备工具
echo "正在检查依赖..."
apt update -y >/dev/null 2>&1
apt install dnsutils curl -y >/dev/null 2>&1

# 2. 定义脚本路径
SCRIPT_PATH="/usr/local/bin/warmup_pro.sh"

# 3. 生成核心逻辑脚本 (使用单引号界定符，防止变量提前解析)
cat > "\$SCRIPT_PATH" <<'INNER_EOF'
#!/bin/bash
# --- 配置区域 ---
LOG_FILE="/var/log/warmup.log"
MAX_LOG_LINES=1000  # 只保留最近1000条日志，防止炸盘

# 目标列表 (针对 TikTok 运营优化)
TARGETS=(
    "www.google.com"
    "www.youtube.com"
    "www.tiktok.com"
    "github.com"
    "api.github.com"
)

# --- 颜色定义 ---
GREEN='\033[0;32m'
RED='\033[0;31m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m'

# --- 日志轮转 (防炸盘) ---
if [ -f "\$LOG_FILE" ]; then
    tail -n \$MAX_LOG_LINES "\$LOG_FILE" > "\$LOG_FILE.tmp" && mv "\$LOG_FILE.tmp" "\$LOG_FILE"
fi

echo "----------------------------------------------------------------" >> \$LOG_FILE
echo "⏰ 预热任务开始: \$(date '+%Y-%m-%d %H:%M:%S')" >> \$LOG_FILE

# 如果是手动运行，显示表头
if [ -t 1 ]; then
    clear
    echo -e "\${CYAN}>>> 开始执行全链路预热 (DNS + TCP Handshake)...\${NC}\n"
    printf "%-25s %-10s %-15s %-10s\n" "目标域名" "DNS状态" "连接状态" "延迟"
    echo "---------------------------------------------------------------------"
fi

for domain in "\${TARGETS[@]}"; do
    # 1. DNS 强制刷新 (向 1.1.1.1 发起查询)
    dig +short \$domain @1.1.1.1 >/dev/null 2>&1
    
    # 2. 混合探测 (优先用 Curl 模拟真实访问，失败则用 Ping)
    # -o /dev/null: 不下载内容
    # -s: 静默
    # -w: 输出格式化数据
    # --connect-timeout 2: 2秒超时
    CURL_RES=\$(curl -o /dev/null -s -w "%{http_code}:%{time_connect}" --connect-timeout 2 "https://\$domain")
    
    if [ \$? -eq 0 ]; then
        # 提取 Curl 数据 (HTTP状态码:握手耗时)
        HTTP_CODE=\$(echo "\$CURL_RES" | cut -d':' -f1)
        TIME_SEC=\$(echo "\$CURL_RES" | cut -d':' -f2)
        # 秒转毫秒
        TIME_MS=\$(awk -v t="\$TIME_SEC" 'BEGIN{printf "%.2f", t*1000}')
        
        STATUS_MSG="✅ 握手成功"
        LOG_MSG="[\$domain] OK - 握手耗时: \${TIME_MS}ms (HTTP \$HTTP_CODE)"
        
        if [ -t 1 ]; then
            printf "%-25s \${GREEN}%-10s\${NC} \${GREEN}%-15s\${NC} %-10s\n" "\$domain" "已刷新" "HTTP握手" "\${TIME_MS}ms"
        fi
    else
        # 如果 Curl 失败，尝试 Ping (保底)
        PING_RES=\$(ping -c 1 -W 1 \$domain 2>/dev/null)
        if [ \$? -eq 0 ]; then
            TIME_MS=\$(echo "\$PING_RES" | grep "time=" | awk -F 'time=' '{print \$2}' | awk '{print \$1}')
            STATUS_MSG="⚠️ 仅Ping通"
            LOG_MSG="[\$domain] Ping OK - 延迟: \${TIME_MS}ms (Web服务未响应)"
            if [ -t 1 ]; then
                printf "%-25s \${GREEN}%-10s\${NC} \${YELLOW}%-15s\${NC} %-10s\n" "\$domain" "已刷新" "仅Ping通" "\${TIME_MS}ms"
            fi
        else
            STATUS_MSG="❌ 彻底失败"
            LOG_MSG="[\$domain] FAILED - 无法连接"
            if [ -t 1 ]; then
                printf "%-25s \${GREEN}%-10s\${NC} \${RED}%-15s\${NC} --\n" "\$domain" "已刷新" "连接超时"
            fi
        fi
    fi
    
    echo "\$LOG_MSG" >> \$LOG_FILE
done

echo "🏁 任务结束" >> \$LOG_FILE

if [ -t 1 ]; then
    echo -e "\n\${CYAN}>>> 所有目标预热完成！路由表与DNS缓存已更新。\${NC}"
    echo -e "📝 日志位置: \${YELLOW}\$LOG_FILE\${NC}"
fi
INNER_EOF

# 4. 赋予执行权限
chmod +x "\$SCRIPT_PATH"

# 5. 添加到 Crontab (每分钟执行，完全静默)
# 先清理旧的，防止重复
crontab -l 2>/dev/null | grep -v "warmup_pro.sh" | crontab -
# 添加新的
(crontab -l 2>/dev/null; echo "* * * * * \$SCRIPT_PATH >/dev/null 2>&1") | crontab -

# 6. 立即手动运行一次以展示效果
bash "\$SCRIPT_PATH"
EOF
)
